/**
 * Simple HID gamepad, 32 buttons + 2x 3 axis + 8 position hat
 * author: chegewara
 */
#include <Arduino.h>
#include "USB.h"
#include "USBHIDGamepad.h"

/******************测试******************/

/****************************************/

/*
 * GPIO 0, 2, 4, 5, 12, 15使用时要注意上电时引脚电平
 * GPIO 19, 20为USB引脚
 * 大灯开关引脚 GPIO 21, 47
 * 雨刮器引脚 GPIO 48, 45, 35,
 */

/*   雨刷开关引脚定义
 *  LO   NC INT GND  HI
 *   |   |   |   |   |
 *
 *   |   |       |   |
 */

/*
 *  按钮引脚定义
 *  21 ->> 1 //大灯开关
 *  47 ->> 1 //大灯开关
 *  48 ~ 16 //自定义
 *  14 ->> 30 //雨刮器开关
 *  13 ->> 30 //雨刮器开关
 *  12 ->> 30 //雨刮器开关
 *  15 ->> 示廓灯
 *  16 ->> 大灯
 */

const int inputPins[] = {21, 47, 48, 45, 35, 37, 38, 39, 40, 41, 42, 2, 1, 6, 7};
const int outputButton[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384};
const int numPins = 15;
int lastButtonState[] = {HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH, HIGH};

const int WIPER_OFF = 0;
const int WIPER_INT = 1;
const int WIPER_LO = 2;
const int WIPER_HI = 3;

enum LightState
{
    LIGHT_OFF,
    LIGHT_PARKING,
    LIGHT_HEADLIGHT
};

const int WIPER_SWITCH_LO = 13;
const int WIPER_SWITCH_HI = 12;
const int WIPER_SWITCH_INT = 14;
const int OVERTAKING_LAMP = 11;

const int POSITION_LIGHT = 15;
const int HEADLIGHT = 16;

int WiperStatus = WIPER_OFF;
LightState currentState = LIGHT_OFF;

USBHIDGamepad gamepad;

void pressLightButton()
{
    gamepad.buttons(32768); // 按下灯光切换按钮
    delay(20);
    gamepad.buttons(0); // 释放按钮
}

LightState getLightState()
{
    if (digitalRead(POSITION_LIGHT) == HIGH && digitalRead(HEADLIGHT) == HIGH)
    {
        Serial.println("LIGHT_OFF");
        return LIGHT_OFF; // PIN15 和 PIN16 都为低电平，表示 OFF
    }
    else if (digitalRead(POSITION_LIGHT) == LOW && digitalRead(HEADLIGHT) == HIGH)
    {
        Serial.println("LIGHT_PARKING");
        return LIGHT_PARKING; // PIN15 为高电平，PIN16 为低电平，表示示廓灯
    }
    else if (digitalRead(POSITION_LIGHT) == LOW && digitalRead(HEADLIGHT) == LOW)
    {
        Serial.println("LIGHT_HEADLIGHT");
        return LIGHT_HEADLIGHT; // PIN15 和 PIN16 都为高电平，表示大灯
    }
    return LIGHT_OFF; // 默认返回 OFF
}

void syncHeadLightState(LightState targetState)
{
    while (currentState != targetState)
    {
        pressLightButton();                                             // 模拟按下灯光切换按钮
        currentState = static_cast<LightState>((currentState + 1) % 3); // 更新当前挡位
        delay(50);                                                     // 适当延时，避免过快切换
    }
}

void wiperSpeedUp()
{
    gamepad.buttons(1 << 29);
    delay(20);
    gamepad.buttons(0);
}

void wiperSpeedDown()
{
    gamepad.buttons(1 << 28);
    delay(20);
    gamepad.buttons(0);
}

void overtakingLamp()
{
    gamepad.buttons(1 << 27);
}

void setup()
{
    for (int i = 0; i < numPins; i++)
    {
        pinMode(inputPins[i], INPUT_PULLUP);
    }
    pinMode(WIPER_SWITCH_LO, INPUT_PULLUP);
    pinMode(WIPER_SWITCH_HI, INPUT_PULLUP);
    pinMode(WIPER_SWITCH_INT, INPUT_PULLUP);
    pinMode(OVERTAKING_LAMP, INPUT_PULLUP);
    pinMode(POSITION_LIGHT, INPUT_PULLUP);
    pinMode(HEADLIGHT, INPUT_PULLUP);
    Serial.begin(115200);
    gamepad.begin();
}

void loop()
{
    for (int i = 0; i < numPins; i++)
    {
        int buttonState = digitalRead(inputPins[i]); // 读取按钮状态
        // 检查按钮状态是否发生变化
        if (buttonState != lastButtonState[i])
        {
            if (buttonState == LOW)
            {
                Serial.print("Pin");
                Serial.print(inputPins[i]);
                Serial.println(" triggered"); // 按钮按下时输出
                gamepad.buttons(outputButton[i]);
                delay(50);
                gamepad.buttons(0);
                Serial.printf("button %d is triggered\n", outputButton[i]);
            }
            else
            {
                Serial.print("Pin");
                Serial.print(inputPins[i]);
                Serial.println(" released"); // 按钮释放时输出
                gamepad.buttons(outputButton[i]);
                delay(50);
                gamepad.buttons(0);
                Serial.printf("button %d is triggered\n", outputButton[i]);
            }
            lastButtonState[i] = buttonState; // 更新上一次按钮状态
        }

        // 短暂延时以避免抖动
        delay(20);

        LightState targetState = getLightState();

        // 如果目标挡位与当前挡位不一致，同步挡位
        if (targetState != currentState)
        {
            syncHeadLightState(targetState);
        }

        //   雨刮器控制逻辑
        //   14 雨刮器开关INT
        //   13 雨刮器开关LO
        //   12 雨刮器开关HI
        if (digitalRead(WIPER_SWITCH_INT) == HIGH && digitalRead(WIPER_SWITCH_LO) == HIGH && digitalRead(WIPER_SWITCH_HI) == HIGH && WiperStatus != WIPER_OFF)
        // 三个引脚全为高，说明此时开关在OFF挡位
        {
            Serial.println("Wiper OFF");
            if (WiperStatus == WIPER_INT)
            {
                wiperSpeedDown();
            }
            else if (WiperStatus == WIPER_LO)
            {
                for (int i = 0; i < 2; i++)
                {
                    wiperSpeedDown();
                }
            }
            else if (WiperStatus == WIPER_HI)
            {
                for (int i = 0; i < 3; i++)
                {
                    wiperSpeedDown();
                }
            }
            WiperStatus = WIPER_OFF;
        }
        else if (digitalRead(WIPER_SWITCH_INT) == LOW && digitalRead(WIPER_SWITCH_LO) == HIGH && digitalRead(WIPER_SWITCH_HI) == HIGH && WiperStatus != WIPER_INT)
        // INT引脚为低，其他引脚为高，此时处于INT挡位
        {
            Serial.println("Wiper INT");
            if (WiperStatus == WIPER_OFF)
            {
                wiperSpeedUp();
            }
            else if (WiperStatus == WIPER_LO)
            {
                wiperSpeedDown();
            }
            else if (WiperStatus == WIPER_HI)
            {
                for (int i = 0; i < 2; i++)
                {
                    wiperSpeedDown();
                }
            }
            WiperStatus = WIPER_INT;
        }
        else if (digitalRead(WIPER_SWITCH_INT) == HIGH && digitalRead(WIPER_SWITCH_LO) == LOW && digitalRead(WIPER_SWITCH_HI) == HIGH && WiperStatus != WIPER_LO)
        // LO引脚为低，其他引脚为高，此时处于LO挡位
        {
            Serial.println("Wiper LO");
            if (WiperStatus == WIPER_OFF)
            {
                for (int i = 0; i < 2; i++)
                {
                    wiperSpeedUp();
                }
            }
            else if (WiperStatus == WIPER_INT)
            {
                wiperSpeedUp();
            }
            else if (WiperStatus == WIPER_HI)
            {
                wiperSpeedDown();
            }
            WiperStatus = WIPER_LO;
        }
        else if (digitalRead(WIPER_SWITCH_INT) == HIGH && digitalRead(WIPER_SWITCH_LO) == HIGH && digitalRead(WIPER_SWITCH_HI) == LOW && WiperStatus != WIPER_HI)
        // HI引脚为低，其他引脚为高，此时处于HI挡位
        {
            Serial.println("Wiper HI");
            if (WiperStatus == WIPER_OFF)
            {
                for (int i = 0; i < 3; i++)
                {
                    wiperSpeedUp();
                }
            }
            else if (WiperStatus == WIPER_INT)
            {
                for (int i = 0; i < 2; i++)
                {
                    wiperSpeedUp();
                }
            }
            else if (WiperStatus == WIPER_LO)
            {
                wiperSpeedUp();
            }
            WiperStatus = WIPER_HI;
        }
    }
    if (digitalRead(OVERTAKING_LAMP) == LOW)
    {
        overtakingLamp();
    }
    else if (digitalRead(OVERTAKING_LAMP) == HIGH)
    {
        gamepad.buttons(0);
    }
}
